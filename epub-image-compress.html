<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EPUB Image Compression ‚Äì Toolbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #131313;
      color: #f9f9f9;
    }
    h1, h2 {
      margin-top: 0;
      margin-bottom: 0.25rem;
      color: #50e3c2;
    }
    .subtitle {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .back-link {
      display: inline-block;
      margin-bottom: 1rem;
      color: #50e3c2;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    .card {
      background: #1f1f1f;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      margin-bottom: 1.5rem;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.1rem;
      font-size: 0.95rem;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    button.primary {
      background: #50e3c2;
      color: #131313;
      font-weight: 600;
    }
    button.primary:hover:not(:disabled) {
      background: #3dd4b3;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    input[type="number"] {
      padding: 0.5rem;
      border-radius: 6px;
      border: 1px solid #3a3a3a;
      background: #2a2a2a;
      color: #f9f9f9;
      font-size: 0.9rem;
      width: 100px;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-top: 1rem;
    }
    .controls-row label {
      font-size: 0.9rem;
      color: #50e3c2;
      font-weight: 500;
    }
    .hint {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-top: 0.5rem;
    }
    .drop-zone {
      border: 2px dashed #3a3a3a;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      background: #2a2a2a;
      transition: all 0.2s;
      cursor: pointer;
    }
    .drop-zone.drag-over {
      border-color: #50e3c2;
      background: #1a3a35;
    }
    .drop-zone.has-file {
      border-color: #10b981;
      background: #064e3b;
    }
    .drop-zone .drop-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      color: #50e3c2;
    }
    .drop-zone.has-file .drop-icon {
      color: #10b981;
    }
    .file-input-wrapper {
      margin-top: 1rem;
    }
    .file-input-wrapper input[type="file"] {
      display: none;
    }
    .browse-btn {
      display: inline-block;
      padding: 0.6rem 1.1rem;
      background: #3a3a3a;
      color: #f9f9f9;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }
    .browse-btn:hover {
      background: #4a4a4a;
    }
    .status {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 1rem 1.5rem;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 500;
      display: none;
      z-index: 9999;
      min-width: 300px;
      max-width: 500px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      animation: slideDown 0.3s ease-out;
    }
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    .status.success {
      background: #064e3b;
      color: #6ee7b7;
      border: 1px solid #10b981;
    }
    .status.error {
      background: #7f1d1d;
      color: #fca5a5;
      border: 1px solid #dc2626;
    }
    .status.info {
      background: #1e3a5f;
      color: #93c5fd;
      border: 1px solid #2563eb;
    }
    .progress {
      margin-top: 1rem;
      display: none;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #2a2a2a;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 0.5rem;
    }
    .progress-fill {
      height: 100%;
      background: #50e3c2;
      transition: width 0.3s;
      width: 0%;
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">‚Üê Back to Toolbox</a>

  <h1>EPUB Image Compression</h1>
  <p class="subtitle">
    Compress and resize images within EPUB files while preserving structure and metadata
  </p>

  <div class="card">
    <h2>Upload EPUB File</h2>
    <div class="drop-zone" id="epubDropZone">
      <div class="drop-icon">üìï</div>
      <p><strong>Drag and drop EPUB file here</strong></p>
      <p>or</p>
      <div class="file-input-wrapper">
        <label for="epubFile" class="browse-btn">Browse Files</label>
        <input type="file" id="epubFile" accept=".epub" />
      </div>
    </div>
    <div class="hint">Upload an EPUB file to compress all images within it</div>
  </div>

  <div class="card">
    <h2>Compression Settings</h2>
    <div class="controls-row">
      <div>
        <label for="maxWidth">Max Width (px):</label>
        <input type="number" id="maxWidth" value="1800" min="100" max="4000" />
      </div>
      <div>
        <label for="maxHeight">Max Height (px):</label>
        <input type="number" id="maxHeight" value="1800" min="100" max="4000" />
      </div>
      <div>
        <label for="quality">Quality (%):</label>
        <input type="number" id="quality" value="85" min="1" max="100" />
      </div>
    </div>
    <div class="controls-row">
      <label style="cursor: pointer;">
        <input type="checkbox" id="enableResize" checked />
        Enable resize (fit within max width/height)
      </label>
      <label style="cursor: pointer;">
        <input type="checkbox" id="convertToJpg" checked />
        Convert output to JPG
      </label>
    </div>
    <div class="hint">Images larger than max dimensions will be resized proportionally (if enabled). Quality affects JPG compression. Converting to JPG reduces file size.</div>

    <button class="primary" id="compressBtn" disabled>Compress EPUB Images</button>

    <div class="progress" id="progress">
      <p id="progressText">Processing...</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
  </div>

  <div class="status" id="status"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    const epubFileInput = document.getElementById('epubFile');
    const epubDropZone = document.getElementById('epubDropZone');
    const compressBtn = document.getElementById('compressBtn');
    const status = document.getElementById('status');
    const progress = document.getElementById('progress');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');
    const maxWidthInput = document.getElementById('maxWidth');
    const maxHeightInput = document.getElementById('maxHeight');
    const enableResizeCheckbox = document.getElementById('enableResize');
    const convertToJpgCheckbox = document.getElementById('convertToJpg');

    let epubFile = null;
    let statusTimeout;

    // Sync resize controls
    function syncResizeControls() {
      const enabled = enableResizeCheckbox.checked;
      maxWidthInput.disabled = !enabled;
      maxHeightInput.disabled = !enabled;
    }

    enableResizeCheckbox.addEventListener('change', syncResizeControls);
    syncResizeControls();

    // Drag and drop handlers
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(element) {
      element.classList.add('drag-over');
    }

    function unhighlight(element) {
      element.classList.remove('drag-over');
    }

    function setupDropZone(dropZone, onDrop) {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
      });

      dropZone.addEventListener('dragenter', () => highlight(dropZone), false);
      dropZone.addEventListener('dragover', () => highlight(dropZone), false);
      dropZone.addEventListener('dragleave', (e) => {
        if (e.target === dropZone) {
          unhighlight(dropZone);
        }
      }, false);
      dropZone.addEventListener('drop', (e) => {
        unhighlight(dropZone);
        onDrop(e);
      }, false);
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      document.body.addEventListener(eventName, (e) => {
        e.preventDefault();
      }, false);
    });

    setupDropZone(epubDropZone, (e) => {
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.name.endsWith('.epub')) {
          handleEpubSelection(file);
        } else {
          showStatus('Please drop an EPUB file', 'error');
        }
      }
    });

    epubFileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleEpubSelection(e.target.files[0]);
      }
    });

    function handleEpubSelection(file) {
      epubFile = file;
      epubDropZone.classList.add('has-file');
      compressBtn.disabled = false;
      showStatus('EPUB file loaded successfully', 'success');
    }

    function showStatus(message, type) {
      status.textContent = message;
      status.className = 'status ' + type;
      status.style.display = 'block';

      if (statusTimeout) clearTimeout(statusTimeout);

      const delay = type === 'error' ? 8000 : 5000;
      statusTimeout = setTimeout(() => {
        status.style.display = 'none';
      }, delay);
    }

    function showProgress(text, percent) {
      progress.style.display = 'block';
      progressText.textContent = text;
      progressFill.style.width = percent + '%';
    }

    function hideProgress() {
      progress.style.display = 'none';
      progressFill.style.width = '0%';
    }

    compressBtn.addEventListener('click', async () => {
      if (!epubFile) {
        showStatus('Please upload an EPUB file first', 'error');
        return;
      }

      compressBtn.disabled = true;
      showProgress('Loading EPUB...', 10);

      try {
        const zip = new JSZip();
        const epubData = await zip.loadAsync(epubFile);

        showProgress('Finding images...', 20);

        // Find all image files
        const imageFiles = [];
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];

        epubData.forEach((relativePath, file) => {
          if (!file.dir) {
            const ext = relativePath.toLowerCase().substring(relativePath.lastIndexOf('.'));
            if (imageExtensions.includes(ext)) {
              imageFiles.push({ path: relativePath, file: file });
            }
          }
        });

        if (imageFiles.length === 0) {
          showStatus('No images found in EPUB', 'info');
          compressBtn.disabled = false;
          hideProgress();
          return;
        }

        showProgress(`Compressing ${imageFiles.length} images...`, 30);

        // Get compression settings
        const maxWidth = parseInt(document.getElementById('maxWidth').value);
        const maxHeight = parseInt(document.getElementById('maxHeight').value);
        const quality = parseInt(document.getElementById('quality').value) / 100;
        const enableResize = enableResizeCheckbox.checked;
        const convertToJpg = convertToJpgCheckbox.checked;

        // Compress each image
        let processedCount = 0;
        for (const imageFile of imageFiles) {
          const imageData = await imageFile.file.async('blob');

          // Determine output filename (change extension if converting to JPG)
          let outputPath = imageFile.path;
          if (convertToJpg && !imageFile.path.toLowerCase().endsWith('.jpg') && !imageFile.path.toLowerCase().endsWith('.jpeg')) {
            outputPath = imageFile.path.substring(0, imageFile.path.lastIndexOf('.')) + '.jpg';
          }

          const compressedBlob = await compressImage(imageData, maxWidth, maxHeight, quality, enableResize, convertToJpg);

          // Replace the image in the zip (with new path if converted to JPG)
          if (outputPath !== imageFile.path) {
            // Remove old file and add new one
            zip.remove(imageFile.path);
          }
          zip.file(outputPath, compressedBlob);

          processedCount++;
          const percent = 30 + (processedCount / imageFiles.length) * 60;
          showProgress(`Compressed ${processedCount}/${imageFiles.length} images...`, percent);
        }

        showProgress('Creating compressed EPUB...', 95);

        // Generate the new EPUB
        const compressedEpub = await zip.generateAsync({
          type: 'blob',
          mimeType: 'application/epub+zip',
          compression: 'DEFLATE',
          compressionOptions: { level: 9 }
        });

        showProgress('Download ready!', 100);

        // Download the compressed EPUB
        const filename = epubFile.name.replace('.epub', '_compressed.epub');
        const link = document.createElement('a');
        link.href = URL.createObjectURL(compressedEpub);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);

        showStatus(`Successfully compressed ${imageFiles.length} images!`, 'success');
        setTimeout(hideProgress, 2000);

      } catch (error) {
        console.error('Error processing EPUB:', error);
        showStatus('Error processing EPUB: ' + error.message, 'error');
        hideProgress();
      } finally {
        compressBtn.disabled = false;
      }
    });

    async function compressImage(blob, maxWidth, maxHeight, quality, enableResize, convertToJpg) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(blob);

        img.onload = async () => {
          URL.revokeObjectURL(url);

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Calculate new dimensions
          let width = img.width;
          let height = img.height;

          if (enableResize && (width > maxWidth || height > maxHeight)) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
          }

          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);

          // Determine output format
          const outputType = convertToJpg ? 'image/jpeg' : (blob.type || 'image/jpeg');
          const outputQuality = convertToJpg ? quality : 1.0;

          // Convert to specified format
          canvas.toBlob((compressedBlob) => {
            if (compressedBlob) {
              resolve(compressedBlob);
            } else {
              reject(new Error('Failed to compress image'));
            }
          }, outputType, outputQuality);
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Failed to load image'));
        };

        img.src = url;
      });
    }
  </script>
</body>
</html>
