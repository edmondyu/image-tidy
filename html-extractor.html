<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HTML Text Extractor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1.5rem;
      padding: 1.75rem;
      box-shadow: 0 24px 80px rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.4);
      backdrop-filter: blur(18px);
    }

    h1 {
      margin: 0 0 0.25rem;
      font-size: 1.6rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    h1 span.logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.9rem;
      height: 1.9rem;
      border-radius: 0.9rem;
      background: radial-gradient(circle at 0 0, #38bdf8, #6366f1);
      font-size: 1.1rem;
    }

    .subtitle {
      margin: 0 0 1.25rem;
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.2fr);
      gap: 1.25rem;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      border-radius: 1rem;
      padding: 1.1rem 1.1rem 1rem;
      background: radial-gradient(circle at top left, #1f2937, #020617 60%);
      border: 1px solid rgba(148, 163, 184, 0.4);
      min-height: 120px;
    }

    .panel h2 {
      margin: 0 0 0.75rem;
      font-size: 1rem;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .panel h2 span.badge {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      background: rgba(15, 118, 110, 0.2);
      color: #6ee7b7;
      border: 1px solid rgba(45, 212, 191, 0.35);
    }

    .file-drop {
      border-radius: 0.9rem;
      border: 1px dashed rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.7);
      padding: 1.1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease,
        transform 0.1s ease;
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .file-drop strong {
      color: #e5e7eb;
    }

    .file-drop.dragover {
      border-color: #38bdf8;
      background: rgba(15, 23, 42, 0.95);
      transform: translateY(-1px);
    }

    .file-drop input {
      display: none;
    }

    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.5rem;
    }

    .options {
      margin-top: 0.85rem;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #d1d5db;
    }

    .option-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem 1rem;
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.65rem 1.2rem;
    }

    label.inline {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      cursor: pointer;
    }

    input[type="checkbox"] {
      width: 0.9rem;
      height: 0.9rem;
      border-radius: 0.25rem;
      border: 1px solid rgba(156, 163, 175, 0.8);
      background: #020617;
      accent-color: #38bdf8;
    }

    input[type="text"] {
      background: #020617;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 0.4rem 0.7rem;
      font-size: 0.78rem;
      color: #e5e7eb;
      min-width: 0;
    }

    input[type="text"]::placeholder {
      color: #6b7280;
    }

    .small-label {
      font-size: 0.78rem;
      color: #9ca3af;
    }

    .merge-name-wrapper {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.4rem;
    }

    .controls {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: space-between;
    }

    .left-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }

    button {
      border-radius: 999px;
      border: none;
      cursor: pointer;
      padding: 0.45rem 0.95rem;
      font-size: 0.78rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #0b1120;
      box-shadow: 0 12px 30px rgba(56, 189, 248, 0.35);
      transition: transform 0.08s ease, box-shadow 0.08s ease,
        opacity 0.12s ease, background 0.12s ease;
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.65);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(56, 189, 248, 0.4);
    }

    button.secondary:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.8);
      background: rgba(15, 23, 42, 1);
    }

    button span.key {
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.2);
      background: rgba(15, 23, 42, 0.15);
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .status {
      font-size: 0.78rem;
      color: #9ca3af;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .status-dot {
      width: 0.5rem;
      height: 0.5rem;
      border-radius: 999px;
      background: #4ade80;
      box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
    }

    .status-dot.idle {
      background: #6b7280;
      box-shadow: none;
    }

    .status-dot.error {
      background: #f97373;
      box-shadow: 0 0 10px rgba(248, 113, 113, 0.6);
    }

    .results-list {
      margin-top: 0.25rem;
      max-height: 380px;
      overflow: auto;
      border-radius: 0.7rem;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top left, #020617, #020617 55%);
    }

    .result-empty {
      padding: 1.1rem;
      font-size: 0.8rem;
      color: #6b7280;
      text-align: center;
    }

    .result-item {
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
    }

    .result-item:last-child {
      border-bottom: none;
    }

    .result-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.55rem 0.75rem;
      font-size: 0.8rem;
      background: rgba(15, 23, 42, 0.9);
    }

    .result-file {
      font-weight: 500;
      color: #e5e7eb;
      word-break: break-all;
    }

    .result-meta {
      font-size: 0.72rem;
      color: #9ca3af;
      display: flex;
      gap: 0.4rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.15rem;
    }

    .result-body {
      padding: 0.55rem 0.75rem 0.65rem;
    }

    .result-text {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.76rem;
      white-space: pre-wrap;
      max-height: 200px;
      overflow: auto;
      padding: 0.55rem 0.55rem;
      border-radius: 0.55rem;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(31, 41, 55, 0.9);
    }

    .pill {
      padding: 0.12rem 0.5rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(55, 65, 81, 0.9);
    }

    .pill.small {
      font-size: 0.7rem;
    }

    .badge-soft {
      font-size: 0.7rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(37, 99, 235, 0.45);
      background: rgba(37, 99, 235, 0.15);
      color: #bfdbfe;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <main class="app">
    <header>
      <h1>
        <span class="logo">H</span>
        HTML Text Extractor
      </h1>
      <p class="subtitle">
        Drop HTML files, extract cleaned text (with tag-style markers and image
        hints), and download as plain text — either per file or merged into a
        single document.
      </p>
    </header>

    <section class="grid" aria-label="HTML extractor workspace">
      <section class="panel" aria-label="Upload & options">
        <h2>
          Source HTML
          <span class="badge">Input</span>
        </h2>

        <div
          class="file-drop"
          id="file-drop"
          tabindex="0"
          role="button"
          aria-label="Drop HTML files here or click to select"
        >
          <input
            type="file"
            id="file-input"
            accept=".html,.htm,.xhtml,.xml"
            multiple
          />
          <div>
            <strong>Drop HTML files here</strong> or click to browse
          </div>
          <div class="hint">
            We’ll parse each HTML, keep basic structure markers (headings,
            paragraphs, lists) and add markers for images.
          </div>
        </div>

        <div class="options">
          <div class="option-row">
            <div class="checkbox-group">
              <label class="inline" title="Include heading markers like #, ##">
                <input type="checkbox" id="opt-headings" checked />
                <span>Preserve headings</span>
              </label>

              <label class="inline" title="Include paragraph breaks">
                <input type="checkbox" id="opt-paragraphs" checked />
                <span>Preserve paragraphs</span>
              </label>

              <label
                class="inline"
                title="Insert markers where images appear (with alt/src)"
              >
                <input type="checkbox" id="opt-images" checked />
                <span>Add image markers</span>
              </label>
            </div>
          </div>

          <!-- NEW MERGE OPTION -->
          <div class="option-row">
            <label class="inline" title="Download a single merged text file">
              <input type="checkbox" id="opt-merge" />
              <span>Merge all extracted text into a single file when downloading</span>
            </label>
          </div>

          <div class="option-row" id="merge-name-row" class="hidden">
            <div class="merge-name-wrapper">
              <span class="small-label">Merged filename:</span>
              <input
                type="text"
                id="merge-filename"
                value="merged_text.txt"
                aria-label="Merged output filename"
              />
            </div>
          </div>
          <!-- END MERGE OPTION -->
        </div>

        <div class="controls">
          <div class="left-controls">
            <button id="btn-extract" type="button">
              Extract text
              <span class="key">Enter</span>
            </button>
            <button
              id="btn-download"
              type="button"
              class="secondary"
              disabled
              title="Download extracted text"
            >
              Download all
            </button>
          </div>

          <div class="status" id="status">
            <span class="status-dot idle" id="status-dot"></span>
            <span id="status-text">Idle — no files yet</span>
          </div>
        </div>
      </section>

      <section class="panel" aria-label="Extracted text preview">
        <h2>
          Extracted Text
          <span class="badge">Preview</span>
        </h2>
        <div id="results" class="results-list">
          <div class="result-empty">
            No output yet. Drop HTML files and click <strong>Extract text</strong>
            to see the cleaned content here.
          </div>
        </div>
      </section>
    </section>
  </main>

  <script>
    // --- Simple extraction with tag markers + image markers ---

    const fileDrop = document.getElementById("file-drop");
    const fileInput = document.getElementById("file-input");
    const btnExtract = document.getElementById("btn-extract");
    const btnDownload = document.getElementById("btn-download");
    const resultsEl = document.getElementById("results");
    const statusDot = document.getElementById("status-dot");
    const statusText = document.getElementById("status-text");

    const optHeadings = document.getElementById("opt-headings");
    const optParagraphs = document.getElementById("opt-paragraphs");
    const optImages = document.getElementById("opt-images");
    const optMerge = document.getElementById("opt-merge");
    const mergeNameRow = document.getElementById("merge-name-row");
    const mergeFilenameInput = document.getElementById("merge-filename");

    /** Holds { fileName, text, charCount } per input file */
    let extractedResults = [];
    let selectedFiles = [];

    // --- File input / drag & drop wiring ---

    fileDrop.addEventListener("click", () => fileInput.click());
    fileDrop.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        fileInput.click();
      }
    });

    fileDrop.addEventListener("dragover", (e) => {
      e.preventDefault();
      fileDrop.classList.add("dragover");
    });

    fileDrop.addEventListener("dragleave", (e) => {
      e.preventDefault();
      fileDrop.classList.remove("dragover");
    });

    fileDrop.addEventListener("drop", (e) => {
      e.preventDefault();
      fileDrop.classList.remove("dragover");
      handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener("change", (e) => {
      handleFiles(e.target.files);
    });

    function handleFiles(fileList) {
      selectedFiles = Array.from(fileList).filter((f) =>
        /\.x?html?$|\.xml$/i.test(f.name)
      );

      if (!selectedFiles.length) {
        setStatus("error", "No HTML/XHTML/XML files detected.");
        return;
      }

      setStatus("idle", `${selectedFiles.length} file(s) ready. Click “Extract text”.`);
      extractedResults = [];
      renderResults();
      btnDownload.disabled = true;
    }

    // --- Status helper ---

    function setStatus(mode, text) {
      statusText.textContent = text;
      statusDot.classList.remove("idle", "error");
      if (mode === "processing") {
        statusDot.classList.remove("idle", "error");
      } else if (mode === "error") {
        statusDot.classList.add("error");
      } else {
        statusDot.classList.add("idle");
      }
    }

    // --- Extraction core ---

    btnExtract.addEventListener("click", () => {
      if (!selectedFiles.length) {
        setStatus("error", "Please select some HTML files first.");
        return;
      }
      extractFromFiles(selectedFiles);
    });

    document.addEventListener("keydown", (e) => {
      if ((e.key === "Enter" || e.key === "NumpadEnter") && e.metaKey) {
        btnExtract.click();
      }
    });

    async function extractFromFiles(files) {
      extractedResults = [];
      btnDownload.disabled = true;
      setStatus("processing", "Extracting text...");

      for (const file of files) {
        const text = await file.text();
        const extracted = extractTextFromHtml(text, {
          headings: optHeadings.checked,
          paragraphs: optParagraphs.checked,
          images: optImages.checked,
        });

        extractedResults.push({
          fileName: file.name,
          text: extracted,
          charCount: extracted.length,
        });
      }

      renderResults();

      if (extractedResults.length) {
        const totalChars = extractedResults.reduce(
          (sum, r) => sum + r.charCount,
          0
        );
        const fileLabel =
          extractedResults.length === 1 ? "file" : "files";
        setStatus(
          "idle",
          `Extracted from ${extractedResults.length} ${fileLabel} — ${totalChars.toLocaleString()} characters total.`
        );
        btnDownload.disabled = false;
      } else {
        setStatus("error", "Nothing was extracted.");
      }
    }

    function extractTextFromHtml(htmlString, options) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      const lines = [];

      function handleHeading(el, level) {
        const text = el.textContent.replace(/\s+/g, " ").trim();
        if (!text) return;
        const hashes = "#".repeat(Math.min(level, 6));
        lines.push("");
        lines.push(`${hashes} ${text}`);
      }

      function handleParagraph(el) {
        const text = el.textContent.replace(/\s+/g, " ").trim();
        if (!text) return;
        lines.push("");
        lines.push(text);
      }

      function handleListItem(el) {
        const text = el.textContent.replace(/\s+/g, " ").trim();
        if (!text) return;
        lines.push(`- ${text}`);
      }

      function handleImage(el) {
        if (!options.images) return;
        const alt = (el.getAttribute("alt") || "").trim();
        const src = (el.getAttribute("src") || "").trim();
        let marker = "[IMAGE";
        if (alt) marker += ` alt="${alt}"`;
        if (src) marker += ` src="${src}"`;
        marker += "]";
        lines.push(marker);
      }

      function walk(node) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();

          if (tag === "img") {
            handleImage(node);
            return;
          }

          if (options.headings && /^h[1-6]$/.test(tag)) {
            const level = Number(tag[1]) || 1;
            handleHeading(node, level);
            return; // avoid duplicating inner text
          }

          if (options.paragraphs && tag === "p") {
            handleParagraph(node);
            return; // avoid duplicating inner text
          }

          if (tag === "li") {
            handleListItem(node);
            return; // avoid duplicating inner text
          }

          // generic element: descend into children
          for (const child of node.childNodes) {
            walk(child);
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
          const text = node.nodeValue.replace(/\s+/g, " ").trim();
          if (text) {
            lines.push(text);
          }
        }
      }

      walk(doc.body || doc.documentElement);

      // Clean up multiple blank lines
      return lines
        .join("\n")
        .replace(/\n{3,}/g, "\n\n")
        .trim();
    }

    // --- Results rendering ---

    function renderResults() {
      resultsEl.innerHTML = "";

      if (!extractedResults.length) {
        const empty = document.createElement("div");
        empty.className = "result-empty";
        empty.innerHTML =
          'No output yet. Drop HTML files and click <strong>Extract text</strong> to see the cleaned content here.';
        resultsEl.appendChild(empty);
        return;
      }

      extractedResults.forEach((res, idx) => {
        const wrapper = document.createElement("article");
        wrapper.className = "result-item";

        const header = document.createElement("div");
        header.className = "result-header";

        const fileInfo = document.createElement("div");
        const nameSpan = document.createElement("div");
        nameSpan.className = "result-file";
        nameSpan.textContent = res.fileName;

        const meta = document.createElement("div");
        meta.className = "result-meta";

        const indexPill = document.createElement("span");
        indexPill.className = "pill small";
        indexPill.textContent = `File ${idx + 1}`;

        const charPill = document.createElement("span");
        charPill.className = "pill small";
        charPill.textContent = `${res.charCount.toLocaleString()} chars`;

        meta.appendChild(indexPill);
        meta.appendChild(charPill);

        fileInfo.appendChild(nameSpan);
        fileInfo.appendChild(meta);

        const singleDownloadBtn = document.createElement("button");
        singleDownloadBtn.className = "secondary";
        singleDownloadBtn.type = "button";
        singleDownloadBtn.textContent = "Download .txt";
        singleDownloadBtn.addEventListener("click", () => {
          downloadTextFile(res.text, toTxtName(res.fileName));
        });

        header.appendChild(fileInfo);
        header.appendChild(singleDownloadBtn);

        const body = document.createElement("div");
        body.className = "result-body";

        const textPre = document.createElement("pre");
        textPre.className = "result-text";
        textPre.textContent = res.text || "(empty)";

        body.appendChild(textPre);

        wrapper.appendChild(header);
        wrapper.appendChild(body);

        resultsEl.appendChild(wrapper);
      });
    }

    function toTxtName(fileName) {
      return fileName.replace(/\.[^.]+$/, "") + ".txt";
    }

    // --- Download logic (per-file ZIP or merged TXT) ---

    btnDownload.addEventListener("click", () => {
      if (!extractedResults.length) return;

      if (optMerge.checked) {
        // MERGED SINGLE FILE MODE
        const mergedName =
          (mergeFilenameInput.value || "").trim() || "merged_text.txt";
        const mergedText = buildMergedText(extractedResults);
        downloadTextFile(mergedText, mergedName);
      } else {
        // ORIGINAL BEHAVIOR: PER-FILE EXPORT VIA ZIP-LIKE DOWNLOAD
        // For simplicity and zero dependencies, we'll trigger multiple .txt downloads.
        // If you previously used JSZip, you can swap this block back
        // to your ZIP implementation and just keep the merge branch above.
        extractedResults.forEach((res) => {
          downloadTextFile(res.text, toTxtName(res.fileName));
        });
      }
    });

    function buildMergedText(results) {
      // You can tweak this format if you want fewer markers.
      const parts = [];
      results.forEach((res, idx) => {
        const headerLine = `===== File ${idx + 1}: ${res.fileName} =====`;
        parts.push(headerLine);
        if (res.text.trim()) {
          parts.push("");
          parts.push(res.text.trim());
        }
        parts.push(""); // spacer
      });
      return parts.join("\n").replace(/\n{3,}/g, "\n\n").trim() + "\n";
    }

    function downloadTextFile(text, filename) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // --- Merge UI toggle ---

    optMerge.addEventListener("change", () => {
      if (optMerge.checked) {
        mergeNameRow.classList.remove("hidden");
      } else {
        mergeNameRow.classList.add("hidden");
      }
    });

    // initialise hidden state
    mergeNameRow.classList.add("hidden");
  </script>
</body>
</html>
