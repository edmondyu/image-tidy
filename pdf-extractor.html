<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Extract Text from PDF – Toolbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #111827;
    }
    h1 { margin-top: 0; margin-bottom: 0.25rem; }
    .subtitle { margin-top: 0; margin-bottom: 1.5rem; color: #6b7280; font-size: 0.95rem; }
    .card {
      background: #fff;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      margin-bottom: 1.5rem;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.1rem;
      font-size: 0.95rem;
      margin-right: 0.5rem;
    }
    button.primary { background: #2563eb; color: #fff; }
    button.secondary { background: #e5e7eb; color: #111827; }
    button:disabled { opacity: 0.6; cursor: default; }
    input[type="file"] { margin: 0.75rem 0; }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-top: 0.5rem;
    }
    .option-label {
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    .preview {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      padding: 1rem;
      border-radius: 8px;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      border-radius: 8px;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    a.back {
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      text-decoration: none;
      color: #2563eb;
    }
  </style>

  <!-- PDF.js (UMD build, global pdfjsLib) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
</head>

<body>
<a class="back" href="index.html">← Back to Toolbox</a>

<h1>Extract Text from PDF</h1>
<p class="subtitle">
  Text-based PDFs only. Paragraph & heading detection enabled.
</p>

<div class="card">
  <h2>1. Select PDF</h2>
  <input id="pdf-input" type="file" accept=".pdf,application/pdf" />
</div>

<div class="card">
  <h2>2. Extract & Download</h2>
  <div class="controls-row">
    <button id="extract-btn" class="primary" disabled>Extract Text</button>
    <button id="download-btn" class="secondary" disabled>Download .txt</button>
    <button id="clear-btn" class="secondary">Clear</button>
  </div>

  <div class="controls-row">
    <label class="option-label">
      <input type="checkbox" id="s2t-toggle" />
      Convert Simplified → Traditional Chinese
    </label>
  </div>

  <h3>Preview</h3>
  <div id="preview" class="preview">(no output yet)</div>
</div>

<div class="card">
  <h2>Logs</h2>
  <div id="log" class="log"></div>
</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";

const pdfInput = document.getElementById("pdf-input");
const extractBtn = document.getElementById("extract-btn");
const downloadBtn = document.getElementById("download-btn");
const clearBtn = document.getElementById("clear-btn");
const previewEl = document.getElementById("preview");
const logEl = document.getElementById("log");
const s2tToggle = document.getElementById("s2t-toggle");

let selectedFile = null;
let outputText = "";

function log(msg) {
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function fixCjkSpacing(text) {
  return text.replace(/([\u4E00-\u9FFF])\s+([\u4E00-\u9FFF])/g, "$1$2");
}

async function convertToTraditionalChinese(text) {
  const resp = await fetch("/.netlify/functions/zhconvert", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text })
  });
  if (!resp.ok) throw new Error("zhconvert proxy failed");
  const json = await resp.json();
  return json.data.text;
}

pdfInput.addEventListener("change", () => {
  selectedFile = pdfInput.files[0] || null;
  extractBtn.disabled = !selectedFile;
});

clearBtn.addEventListener("click", () => {
  selectedFile = null;
  pdfInput.value = "";
  extractBtn.disabled = true;
  downloadBtn.disabled = true;
  previewEl.textContent = "(no output yet)";
  logEl.textContent = "";
});

extractBtn.addEventListener("click", async () => {
  if (!selectedFile) return;

  extractBtn.disabled = true;
  logEl.textContent = "";
  previewEl.textContent = "";

  try {
    const buf = await selectedFile.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

    const allLines = [];
    const fontSizes = [];

    for (let p = 1; p <= pdf.numPages; p++) {
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();

      tc.items.forEach(it => {
        if (it.height) fontSizes.push(it.height);
      });

      const rows = {};
      tc.items.forEach(it => {
        const y = Math.round(it.transform[5]);
        rows[y] = rows[y] || [];
        rows[y].push({
          x: it.transform[4],
          text: it.str,
          size: it.height || 0
        });
      });

      Object.keys(rows)
        .sort((a,b)=>b-a)
        .forEach(y => {
          const row = rows[y].sort((a,b)=>a.x-b.x);
          const text = row.map(r=>r.text).join(" ");
          const size = Math.max(...row.map(r=>r.size));
          allLines.push({ text, size });
        });
    }

    const medianFont =
      fontSizes.sort((a,b)=>a-b)[Math.floor(fontSizes.length/2)] || 0;

    const paragraphs = [];
    let buffer = "";

    allLines.forEach(line => {
      const cleaned = fixCjkSpacing(line.text).trim();
      if (!cleaned) return;

      const isHeading =
        line.size > medianFont * 1.3 &&
        cleaned.length < 40;

      if (isHeading) {
        if (buffer) {
          paragraphs.push(buffer.trim());
          buffer = "";
        }
        paragraphs.push("## " + cleaned);
      } else {
        buffer += (buffer ? " " : "") + cleaned;
      }
    });

    if (buffer) paragraphs.push(buffer.trim());

    outputText = paragraphs.join("\n\n");

    if (s2tToggle.checked) {
      log("Converting to Traditional Chinese...");
      outputText = await convertToTraditionalChinese(outputText);
    }

    previewEl.textContent = outputText.slice(0, 6000);
    downloadBtn.disabled = false;

    downloadBtn.onclick = () => {
      const blob = new Blob([outputText], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = selectedFile.name.replace(/\.pdf$/i, "") + ".txt";
      a.click();
      URL.revokeObjectURL(url);
    };

    log("Done.");
  } catch (e) {
    log("Error: " + e.message);
    alert(e.message);
  } finally {
    extractBtn.disabled = false;
  }
});
</script>
</body>
</html>
