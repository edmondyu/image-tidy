<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Batch Image Resizer & Compressor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #333;
    }
    h1 {
      margin-top: 0;
    }
    .card {
      background: #fff;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      margin-bottom: 1.5rem;
    }
    input[type="file"] {
      margin: 0.75rem 0;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.1rem;
      font-size: 0.95rem;
      margin-right: 0.5rem;
    }
    button.primary {
      background: #2563eb;
      color: #fff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      border-radius: 8px;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    .file-list {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0;
      border-bottom: 1px solid #e5e7eb;
    }
    .file-item:last-child {
      border-bottom: none;
    }
    .badge {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #e5e7eb;
      color: #374151;
      margin-left: 0.4rem;
    }
    a.download-link {
      font-size: 0.85rem;
      text-decoration: none;
      color: #2563eb;
      margin-left: 0.7rem;
    }
    .summary {
      font-size: 0.9rem;
      margin-top: 0.5rem;
      color: #374151;
    }
  </style>

  <!-- JSZip for creating ZIP files in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <h1>Batch Image Resizer & Compressor</h1>
  <p>
    Client-side implementation of your Python script:
    resize images larger than 1800px on a side, convert to JPG, then iteratively compress
    until the file is ≤ <strong>50%</strong> of the resized size or quality reaches 10.
  </p>

  <div class="card">
    <h2>1. Select Images</h2>
    <p>Supported formats: <strong>.png, .jpg, .jpeg</strong></p>
    <input id="file-input" type="file" multiple accept=".png,.jpg,.jpeg,image/png,image/jpeg" />
    <div class="file-list" id="file-list"></div>
  </div>

  <div class="card">
    <h2>2. Process & Download</h2>
    <button id="process-btn" class="primary" disabled>Process Images</button>
    <button id="zip-btn" class="secondary" disabled>Download All as ZIP</button>
    <button id="clear-btn" class="secondary">Clear</button>
    <p class="summary" id="summary"></p>
    <div id="downloads"></div>
  </div>

  <div class="card">
    <h2>Logs</h2>
    <div class="log" id="log"></div>
  </div>

  <script>
    // --- Helpers -------------------------------------------------------------

    const fileInput   = document.getElementById("file-input");
    const processBtn  = document.getElementById("process-btn");
    const clearBtn    = document.getElementById("clear-btn");
    const zipBtn      = document.getElementById("zip-btn");
    const logEl       = document.getElementById("log");
    const fileListEl  = document.getElementById("file-list");
    const downloadsEl = document.getElementById("downloads");
    const summaryEl   = document.getElementById("summary");

    let selectedFiles = [];
    let processedResults = [];

    function log(message) {
      logEl.textContent += message + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function bytesToKB(bytes) {
      return (bytes / 1024).toFixed(2) + " KB";
    }

    function replaceExtensionToJpg(name) {
      return name.replace(/\.[^.]+$/, "") + ".jpg";
    }

    // Natural sort key (like Python's natural_sort_key)
    function naturalSortKey(str) {
      return str.split(/(\d+)/).map(part => {
        const n = parseInt(part, 10);
        return isNaN(n) ? part.toLowerCase() : n;
      });
    }

    function naturalCompare(a, b) {
      const ak = naturalSortKey(a);
      const bk = naturalSortKey(b);
      const len = Math.max(ak.length, bk.length);
      for (let i = 0; i < len; i++) {
        if (ak[i] === undefined) return -1;
        if (bk[i] === undefined) return 1;
        if (ak[i] < bk[i]) return -1;
        if (ak[i] > bk[i]) return 1;
      }
      return 0;
    }

    function updateFileList() {
      fileListEl.innerHTML = "";
      if (selectedFiles.length === 0) {
        fileListEl.textContent = "No files selected.";
        processBtn.disabled = true;
        return;
      }
      const listFrag = document.createDocumentFragment();
      selectedFiles.forEach(file => {
        const div = document.createElement("div");
        div.className = "file-item";
        const nameSpan = document.createElement("span");
        nameSpan.textContent = file.name;
        const sizeSpan = document.createElement("span");
        sizeSpan.textContent = bytesToKB(file.size);
        div.appendChild(nameSpan);
        div.appendChild(sizeSpan);
        listFrag.appendChild(div);
      });
      fileListEl.appendChild(listFrag);
      processBtn.disabled = false;
    }

    function clearAll() {
      selectedFiles = [];
      processedResults = [];
      fileInput.value = "";
      fileListEl.textContent = "No files selected.";
      downloadsEl.innerHTML = "";
      summaryEl.textContent = "";
      processBtn.disabled = true;
      zipBtn.disabled = true;
      logEl.textContent = "";
    }

    // Read file as Image
    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = err => reject(err);
          img.src = e.target.result;
        };
        reader.onerror = err => reject(err);
        reader.readAsDataURL(file);
      });
    }

    // Convert canvas to Blob as Promise
    function canvasToBlob(canvas, type = "image/jpeg", quality = 0.85) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (!blob) reject(new Error("Canvas is empty"));
          else resolve(blob);
        }, type, quality);
      });
    }

    // Resize according to your rules
    async function resizeImageBrowser(img) {
      const maxSide = 1800;
      let { width, height } = img;
      let newWidth = width;
      let newHeight = height;
      let resized = false;

      if (width > maxSide || height > maxSide) {
        if (width > height) {
          newWidth = maxSide;
          const scale = newWidth / width;
          newHeight = Math.round(height * scale);
        } else {
          newHeight = maxSide;
          const scale = newHeight / height;
          newWidth = Math.round(width * scale);
        }
        resized = true;
      }

      const canvas = document.createElement("canvas");
      canvas.width = newWidth;
      canvas.height = newHeight;
      const ctx = canvas.getContext("2d");

      // Flatten transparency to white (like converting RGBA → RGB)
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, newWidth, newHeight);
      ctx.drawImage(img, 0, 0, newWidth, newHeight);

      // Save as JPEG with quality 85 (equivalent to script)
      const resizedBlob = await canvasToBlob(canvas, "image/jpeg", 0.85);

      return { canvas, resizedBlob, resized, width, height, newWidth, newHeight };
    }

    // Compression loop (target = 50% of resized size)
    async function compressImageFromCanvas(canvas, resizedBlob) {
      const originalSize = resizedBlob.size;
      const targetSize = originalSize * 0.5; // 50% of resized image size
      let quality = 0.8; // start at 80
      let compressedBlob = resizedBlob; // fallback
      while (true) {
        const blob = await canvasToBlob(canvas, "image/jpeg", quality);
        const size = blob.size;

        if (size <= targetSize || quality <= 0.1) {
          compressedBlob = blob;
          break;
        }
        quality -= 0.05; // decrease by 5
      }
      return compressedBlob;
    }

    // --- Event handlers ------------------------------------------------------

    fileInput.addEventListener("change", () => {
      const files = Array.from(fileInput.files || []);
      const filtered = files.filter(f =>
        /\.(png|jpe?g)$/i.test(f.name)
      );
      filtered.sort((a, b) => naturalCompare(a.name, b.name));
      selectedFiles = filtered;
      processedResults = [];
      downloadsEl.innerHTML = "";
      summaryEl.textContent = "";
      zipBtn.disabled = true;
      logEl.textContent = "";
      if (files.length !== filtered.length) {
        log("Some files were ignored (unsupported extension).");
      }
      if (filtered.length === 0) {
        fileListEl.textContent = "No valid image files selected.";
        processBtn.disabled = true;
      } else {
        updateFileList();
        log(`Selected ${filtered.length} image(s).`);
      }
    });

    clearBtn.addEventListener("click", () => {
      clearAll();
    });

    processBtn.addEventListener("click", async () => {
      if (selectedFiles.length === 0) return;

      processBtn.disabled = true;
      clearBtn.disabled = true;
      zipBtn.disabled = true;
      downloadsEl.innerHTML = "";
      processedResults = [];
      summaryEl.textContent = "";
      logEl.textContent = "";
      log(`Starting processing of ${selectedFiles.length} image(s)...`);

      let totalOriginal = 0;
      let totalCompressed = 0;

      for (let i = 0; i < selectedFiles.length; i++) {
        const file = selectedFiles[i];
        const index = i + 1;
        log(`\n[${index}/${selectedFiles.length}] Processing "${file.name}"`);

        totalOriginal += file.size;

        try {
          const img = await loadImageFromFile(file);
          const {
            canvas,
            resizedBlob,
            resized,
            width,
            height,
            newWidth,
            newHeight
          } = await resizeImageBrowser(img);

          const resizedKB = bytesToKB(resizedBlob.size);
          if (resized) {
            log(`Resized from ${width}x${height} to ${newWidth}x${newHeight}, size ~ ${resizedKB}`);
          } else {
            log(`No resize needed (${width}x${height}), saved as JPEG ~ ${resizedKB}`);
          }

          const compressedBlob = await compressImageFromCanvas(canvas, resizedBlob);
          const compressedKB = bytesToKB(compressedBlob.size);
          totalCompressed += compressedBlob.size;

          log(`Compressed to ~ ${compressedKB} (target <= 50% of resized size)`);

          const outputName = replaceExtensionToJpg(file.name);
          const url = URL.createObjectURL(compressedBlob);

          // Remember for summary & ZIP
          processedResults.push({
            name: outputName,
            originalSize: file.size,
            resizedSize: resizedBlob.size,
            compressedSize: compressedBlob.size,
            blob: compressedBlob,
            url
          });

          // Add a download link row
          const row = document.createElement("div");
          row.className = "file-item";

          const left = document.createElement("div");
          left.textContent = outputName;
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = `${bytesToKB(file.size)} → ${compressedKB}`;
          left.appendChild(badge);

          const right = document.createElement("div");
          const a = document.createElement("a");
          a.href = url;
          a.download = outputName;
          a.className = "download-link";
          a.textContent = "Download";
          right.appendChild(a);

          row.appendChild(left);
          row.appendChild(right);
          downloadsEl.appendChild(row);

        } catch (err) {
          log(`Error processing "${file.name}": ${err.message || err}`);
        }
      }

      const savingPercent =
        totalOriginal > 0
          ? ((1 - totalCompressed / totalOriginal) * 100).toFixed(1)
          : 0;

      summaryEl.textContent =
        `Done. Total original: ${bytesToKB(totalOriginal)} → ` +
        `${bytesToKB(totalCompressed)} (saved ~${savingPercent}%).`;

      log("\nAll images processed.");
      processBtn.disabled = false;
      clearBtn.disabled = false;

      if (processedResults.length > 0) {
        zipBtn.disabled = false;
      }
    });

    zipBtn.addEventListener("click", async () => {
      if (processedResults.length === 0) return;

      zipBtn.disabled = true;
      const originalLabel = zipBtn.textContent;
      zipBtn.textContent = "Preparing ZIP...";

      try {
        const zip = new JSZip();
        processedResults.forEach(result => {
          zip.file(result.name, result.blob);
        });

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "compressed_images.zip";
        document.body.appendChild(a);
        a.click();
        a.remove();

        // Revoke URL after a short delay
        setTimeout(() => URL.revokeObjectURL(url), 10000);
      } catch (err) {
        log(`Error creating ZIP: ${err.message || err}`);
      } finally {
        zipBtn.textContent = originalLabel;
        zipBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
