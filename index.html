<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Toolbox – Image Compression & HTML Text Extractor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Layout & base styles */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #111827;
    }
    h1 {
      margin-top: 0;
      margin-bottom: 0.25rem;
    }
    .subtitle {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: #6b7280;
      font-size: 0.95rem;
    }
    .card {
      background: #fff;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      margin-bottom: 1.5rem;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-radius: 999px;
      background: #e5e7eb;
      padding: 0.25rem;
      margin-bottom: 1rem;
      gap: 0.25rem;
      max-width: 420px;
    }
    .tab-btn {
      flex: 1;
      border: none;
      border-radius: 999px;
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: transparent;
      color: #4b5563;
    }
    .tab-btn.active {
      background: #111827;
      color: #f9fafb;
    }

    .tool-section {
      display: none;
    }
    .tool-section.active {
      display: block;
    }

    /* Buttons & inputs */
    button {
      cursor: pointer;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.1rem;
      font-size: 0.95rem;
      margin-right: 0.5rem;
    }
    button.primary {
      background: #2563eb;
      color: #fff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    input[type="file"] {
      margin: 0.75rem 0;
    }
    input[type="number"],
    input[type="text"] {
      padding: 0.25rem 0.4rem;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-top: 0.5rem;
    }
    .controls-row label {
      font-size: 0.9rem;
    }
    .controls-row input[type="number"] {
      width: 90px;
    }
    .hint {
      font-size: 0.85rem;
      color: #6b7280;
    }

    /* Lists & logs */
    .file-list {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0;
      border-bottom: 1px solid #e5e7eb;
    }
    .file-item:last-child {
      border-bottom: none;
    }
    .badge {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #e5e7eb;
      color: #374151;
      margin-left: 0.4rem;
    }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      border-radius: 8px;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    a.download-link {
      font-size: 0.85rem;
      text-decoration: none;
      color: #2563eb;
      margin-left: 0.7rem;
    }
    .summary {
      font-size: 0.9rem;
      margin-top: 0.5rem;
      color: #374151;
    }

    .tag-checkboxes label {
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      margin-right: 0.75rem;
      margin-bottom: 0.25rem;
    }

    @media (max-width: 640px) {
      body {
        padding: 1rem;
      }
    }
  </style>

  <!-- JSZip for creating ZIP files in the browser (image compression) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <h1>Toolbox</h1>
  <p class="subtitle">
    Two browser-only tools: <strong>Image Compression</strong> and <strong>Extract Text from HTML</strong>.
    All processing is local – nothing is uploaded to a server.
  </p>

  <div class="tabs">
    <button class="tab-btn active" data-tool="images">Image Compression</button>
    <button class="tab-btn" data-tool="html">Extract Text from HTML</button>
  </div>

  <!-- ===================== IMAGE COMPRESSION TOOL ====================== -->
  <section id="tool-images" class="tool-section active">
    <div class="card">
      <h2>Image Compression</h2>
      <p>
        Resize and compress multiple images in the browser. Outputs JPGs and lets you download them
        individually or as a ZIP file.
      </p>

      <div class="card" style="margin-top:1rem;">
        <h3>1. Select Images & Parameters</h3>
        <p>Supported formats: <strong>.png, .jpg, .jpeg</strong></p>
        <input id="img-file-input" type="file" multiple accept=".png,.jpg,.jpeg,image/png,image/jpeg" />

        <div class="controls-row">
          <label for="max-width-input">Max width (px):</label>
          <input
            id="max-width-input"
            type="number"
            min="100"
            max="10000"
            step="1"
            value="1800"
          />

          <label for="max-height-input">Max height (px):</label>
          <input
            id="max-height-input"
            type="number"
            min="100"
            max="10000"
            step="1"
            value="1800"
          />
        </div>

        <div class="controls-row">
          <label for="target-percent-input">Target size (% of resized):</label>
          <input
            id="target-percent-input"
            type="number"
            min="1"
            max="100"
            step="1"
            value="50"
          />
          <span class="hint">
            Example: 50 → compressed file ≈ 50% of resized file size.
          </span>
        </div>

        <div class="file-list" id="img-file-list"></div>
      </div>

      <div class="card">
        <h3>2. Process & Download</h3>
        <button id="process-images-btn" class="primary" disabled>Process Images</button>
        <button id="zip-images-btn" class="secondary" disabled>Download All as ZIP</button>
        <button id="clear-images-btn" class="secondary">Clear</button>
        <p class="summary" id="img-summary"></p>
        <div id="img-downloads"></div>
      </div>

      <div class="card">
        <h3>Logs</h3>
        <div class="log" id="img-log"></div>
      </div>
    </div>
  </section>

  <!-- ===================== HTML TEXT EXTRACTOR TOOL ==================== -->
  <section id="tool-html" class="tool-section">
    <div class="card">
      <h2>Extract Text from HTML</h2>
      <p>
        Browser-based port of your BeautifulSoup script:
        <br>• walks through <code>h1–h6, p, footer, sup, small, b, i, u, img</code> in document order
        <br>• preserves only the tags you select below; all others are stripped but their text remains
        <br>• outputs header tags as raw HTML
        <br>• replaces images with <code>[filename]</code> lines
        <br>• generates a separate image filename list per input file
      </p>

      <div class="card" style="margin-top:1rem;">
        <h3>1. Select HTML Files & Tags to Preserve</h3>
        <p>You can select one or more HTML files:</p>
        <input id="html-file-input" type="file" multiple accept=".html,.htm,text/html" />

        <div class="controls-row">
          <span style="font-size:0.9rem;">Preserve tags (inline):</span>
        </div>
        <div class="controls-row tag-checkboxes">
          <label><input type="checkbox" class="tag-preserve-checkbox" value="b" checked> &lt;b&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="i" checked> &lt;i&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="u" checked> &lt;u&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="strong"> &lt;strong&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="em"> &lt;em&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="sup"> &lt;sup&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="sub"> &lt;sub&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="small"> &lt;small&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="a"> &lt;a&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="code"> &lt;code&gt;</label>
          <label><input type="checkbox" class="tag-preserve-checkbox" value="span"> &lt;span&gt;</label>
        </div>
        <p class="hint">
          Only checked tags will be preserved as HTML in the output. All other tags are removed but their text is kept.
        </p>
      </div>

      <div class="card">
        <h3>2. Extract & Download</h3>
        <button id="process-html-btn" class="primary" disabled>Extract Text</button>
        <button id="clear-html-btn" class="secondary">Clear</button>

        <p class="summary" id="html-summary"></p>
        <div id="html-downloads"></div>
      </div>

      <div class="card">
        <h3>Logs</h3>
        <div class="log" id="html-log"></div>
      </div>
    </div>
  </section>

  <script>
    // ========================= TABS ===============================
    const tabButtons = document.querySelectorAll(".tab-btn");
    const toolSections = {
      images: document.getElementById("tool-images"),
      html: document.getElementById("tool-html"),
    };

    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tool = btn.dataset.tool;
        tabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        Object.entries(toolSections).forEach(([key, section]) => {
          section.classList.toggle("active", key === tool);
        });
      });
    });

    // ========================= IMAGE COMPRESSION TOOL =======================

    const imgFileInput      = document.getElementById("img-file-input");
    const maxWidthInput     = document.getElementById("max-width-input");
    const maxHeightInput    = document.getElementById("max-height-input");
    const targetPercentInput= document.getElementById("target-percent-input");
    const processImagesBtn  = document.getElementById("process-images-btn");
    const clearImagesBtn    = document.getElementById("clear-images-btn");
    const zipImagesBtn      = document.getElementById("zip-images-btn");
    const imgLogEl          = document.getElementById("img-log");
    const imgFileListEl     = document.getElementById("img-file-list");
    const imgDownloadsEl    = document.getElementById("img-downloads");
    const imgSummaryEl      = document.getElementById("img-summary");

    let selectedImgFiles = [];
    let processedImgResults = [];

    function imgLog(message) {
      imgLogEl.textContent += message + "\n";
      imgLogEl.scrollTop = imgLogEl.scrollHeight;
    }

    function bytesToKB(bytes) {
      return (bytes / 1024).toFixed(2) + " KB";
    }

    function replaceExtensionToJpg(name) {
      return name.replace(/\.[^.]+$/, "") + ".jpg";
    }

    function naturalSortKey(str) {
      return str.split(/(\d+)/).map(part => {
        const n = parseInt(part, 10);
        return isNaN(n) ? part.toLowerCase() : n;
      });
    }

    function naturalCompare(a, b) {
      const ak = naturalSortKey(a);
      const bk = naturalSortKey(b);
      const len = Math.max(ak.length, bk.length);
      for (let i = 0; i < len; i++) {
        if (ak[i] === undefined) return -1;
        if (bk[i] === undefined) return 1;
        if (ak[i] < bk[i]) return -1;
        if (ak[i] > bk[i]) return 1;
      }
      return 0;
    }

    function updateImgFileList() {
      imgFileListEl.innerHTML = "";
      if (selectedImgFiles.length === 0) {
        imgFileListEl.textContent = "No files selected.";
        processImagesBtn.disabled = true;
        return;
      }
      const frag = document.createDocumentFragment();
      selectedImgFiles.forEach(file => {
        const div = document.createElement("div");
        div.className = "file-item";
        const nameSpan = document.createElement("span");
        nameSpan.textContent = file.name;
        const sizeSpan = document.createElement("span");
        sizeSpan.textContent = bytesToKB(file.size);
        div.appendChild(nameSpan);
        div.appendChild(sizeSpan);
        frag.appendChild(div);
      });
      imgFileListEl.appendChild(frag);
      processImagesBtn.disabled = false;
    }

    function clearImageTool() {
      selectedImgFiles = [];
      processedImgResults = [];
      imgFileInput.value = "";
      imgFileListEl.textContent = "No files selected.";
      imgDownloadsEl.innerHTML = "";
      imgSummaryEl.textContent = "";
      processImagesBtn.disabled = true;
      zipImagesBtn.disabled = true;
      imgLogEl.textContent = "";
    }

    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = err => reject(err);
          img.src = e.target.result;
        };
        reader.onerror = err => reject(err);
        reader.readAsDataURL(file);
      });
    }

    function canvasToBlob(canvas, type = "image/jpeg", quality = 0.85) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (!blob) reject(new Error("Canvas is empty"));
          else resolve(blob);
        }, type, quality);
      });
    }

    function getValidatedMaxWidth() {
      const val = parseInt(maxWidthInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val) || val <= 0) {
        throw new Error("Max width must be a positive integer.");
      }
      if (val < 100 || val > 10000) {
        throw new Error("Max width must be between 100 and 10000 pixels.");
      }
      return val;
    }

    function getValidatedMaxHeight() {
      const val = parseInt(maxHeightInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val) || val <= 0) {
        throw new Error("Max height must be a positive integer.");
      }
      if (val < 100 || val > 10000) {
        throw new Error("Max height must be between 100 and 10000 pixels.");
      }
      return val;
    }

    function getValidatedTargetPercent() {
      const val = parseInt(targetPercentInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val)) {
        throw new Error("Target size must be an integer percentage.");
      }
      if (val < 1 || val > 100) {
        throw new Error("Target size percentage must be between 1 and 100.");
      }
      return val;
    }

    async function resizeImageBrowser(img, maxWidth, maxHeight) {
      let { width, height } = img;
      let newWidth = width;
      let newHeight = height;
      let resized = false;

      if (width > maxWidth || height > maxHeight) {
        const scaleW = maxWidth / width;
        const scaleH = maxHeight / height;
        const scale = Math.min(scaleW, scaleH);
        newWidth = Math.round(width * scale);
        newHeight = Math.round(height * scale);
        resized = true;
      }

      const canvas = document.createElement("canvas");
      canvas.width = newWidth;
      canvas.height = newHeight;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, newWidth, newHeight);
      ctx.drawImage(img, 0, 0, newWidth, newHeight);

      const resizedBlob = await canvasToBlob(canvas, "image/jpeg", 0.85);
      return { canvas, resizedBlob, resized, width, height, newWidth, newHeight };
    }

    async function compressImageFromCanvas(canvas, resizedBlob, targetPercent) {
      const originalSize = resizedBlob.size;
      const targetRatio = targetPercent / 100;
      const targetSize = originalSize * targetRatio;
      let quality = 0.8;
      let compressedBlob = resizedBlob;
      while (true) {
        const blob = await canvasToBlob(canvas, "image/jpeg", quality);
        const size = blob.size;

        if (size <= targetSize || quality <= 0.1) {
          compressedBlob = blob;
          break;
        }
        quality -= 0.05;
      }
      return compressedBlob;
    }

    imgFileInput.addEventListener("change", () => {
      const files = Array.from(imgFileInput.files || []);
      const filtered = files.filter(f => /\.(png|jpe?g)$/i.test(f.name));
      filtered.sort((a, b) => naturalCompare(a.name, b.name));
      selectedImgFiles = filtered;
      processedImgResults = [];
      imgDownloadsEl.innerHTML = "";
      imgSummaryEl.textContent = "";
      zipImagesBtn.disabled = true;
      imgLogEl.textContent = "";
      if (files.length !== filtered.length) {
        imgLog("Some files were ignored (unsupported extension).");
      }
      if (filtered.length === 0) {
        imgFileListEl.textContent = "No valid image files selected.";
        processImagesBtn.disabled = true;
      } else {
        updateImgFileList();
        imgLog(`Selected ${filtered.length} image(s).`);
      }
    });

    clearImagesBtn.addEventListener("click", clearImageTool);

    processImagesBtn.addEventListener("click", async () => {
      if (selectedImgFiles.length === 0) return;

      let maxWidth, maxHeight, targetPercent;
      try {
        maxWidth = getValidatedMaxWidth();
        maxHeight = getValidatedMaxHeight();
        targetPercent = getValidatedTargetPercent();
      } catch (err) {
        imgLog("Parameter error: " + err.message);
        alert(err.message);
        return;
      }

      imgLog(
        `Using max width: ${maxWidth}px, max height: ${maxHeight}px, ` +
        `target size: ${targetPercent}% of resized file size.`
      );

      processImagesBtn.disabled = true;
      clearImagesBtn.disabled = true;
      zipImagesBtn.disabled = true;
      imgDownloadsEl.innerHTML = "";
      processedImgResults = [];
      imgSummaryEl.textContent = "";
      imgLog(`Starting processing of ${selectedImgFiles.length} image(s)...`);

      let totalOriginal = 0;
      let totalCompressed = 0;

      for (let i = 0; i < selectedImgFiles.length; i++) {
        const file = selectedImgFiles[i];
        const index = i + 1;
        imgLog(`\n[${index}/${selectedImgFiles.length}] Processing "${file.name}"`);

        totalOriginal += file.size;

        try {
          const img = await loadImageFromFile(file);
          const {
            canvas,
            resizedBlob,
            resized,
            width,
            height,
            newWidth,
            newHeight
          } = await resizeImageBrowser(img, maxWidth, maxHeight);

          const resizedKB = bytesToKB(resizedBlob.size);
          if (resized) {
            imgLog(`Resized from ${width}x${height} to ${newWidth}x${newHeight}, size ~ ${resizedKB}`);
          } else {
            imgLog(`No resize needed (${width}x${height}), saved as JPEG ~ ${resizedKB}`);
          }

          const compressedBlob = await compressImageFromCanvas(canvas, resizedBlob, targetPercent);
          const compressedKB = bytesToKB(compressedBlob.size);
          totalCompressed += compressedBlob.size;

          imgLog(`Compressed to ~ ${compressedKB} (target <= ${targetPercent}% of resized size)`);

          const outputName = replaceExtensionToJpg(file.name);
          const url = URL.createObjectURL(compressedBlob);

          processedImgResults.push({
            name: outputName,
            originalSize: file.size,
            resizedSize: resizedBlob.size,
            compressedSize: compressedBlob.size,
            blob: compressedBlob,
            url
          });

          const row = document.createElement("div");
          row.className = "file-item";

          const left = document.createElement("div");
          left.textContent = outputName;
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = `${bytesToKB(file.size)} → ${compressedKB}`;
          left.appendChild(badge);

          const right = document.createElement("div");
          const a = document.createElement("a");
          a.href = url;
          a.download = outputName;
          a.className = "download-link";
          a.textContent = "Download";
          right.appendChild(a);

          row.appendChild(left);
          row.appendChild(right);
          imgDownloadsEl.appendChild(row);

        } catch (err) {
          imgLog(`Error processing "${file.name}": ${err.message || err}`);
        }
      }

      const savingPercent =
        totalOriginal > 0
          ? ((1 - totalCompressed / totalOriginal) * 100).toFixed(1)
          : 0;

      imgSummaryEl.textContent =
        `Done. Total original: ${bytesToKB(totalOriginal)} → ` +
        `${bytesToKB(totalCompressed)} (saved ~${savingPercent}%).`;

      imgLog("\nAll images processed.");
      processImagesBtn.disabled = false;
      clearImagesBtn.disabled = false;

      if (processedImgResults.length > 0) {
        zipImagesBtn.disabled = false;
      }
    });

    zipImagesBtn.addEventListener("click", async () => {
      if (processedImgResults.length === 0) return;

      zipImagesBtn.disabled = true;
      const originalLabel = zipImagesBtn.textContent;
      zipImagesBtn.textContent = "Preparing ZIP...";

      try {
        const zip = new JSZip();
        processedImgResults.forEach(result => {
          zip.file(result.name, result.blob);
        });

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "compressed_images.zip";
        document.body.appendChild(a);
        a.click();
        a.remove();

        setTimeout(() => URL.revokeObjectURL(url), 10000);
      } catch (err) {
        imgLog(`Error creating ZIP: ${err.message || err}`);
      } finally {
        zipImagesBtn.textContent = originalLabel;
        zipImagesBtn.disabled = false;
      }
    });

    // ========================= HTML TEXT EXTRACTOR TOOL =====================

    const htmlFileInput       = document.getElementById("html-file-input");
    const processHtmlBtn      = document.getElementById("process-html-btn");
    const clearHtmlBtn        = document.getElementById("clear-html-btn");
    const htmlLogEl           = document.getElementById("html-log");
    const htmlDownloadsEl     = document.getElementById("html-downloads");
    const htmlSummaryEl       = document.getElementById("html-summary");
    const tagCheckboxes       = document.querySelectorAll(".tag-preserve-checkbox");

    let selectedHtmlFiles = [];

    function htmlLog(message) {
      htmlLogEl.textContent += message + "\n";
      htmlLogEl.scrollTop = htmlLogEl.scrollHeight;
    }

    htmlFileInput.addEventListener("change", () => {
      const files = Array.from(htmlFileInput.files || []);
      selectedHtmlFiles = files;
      htmlDownloadsEl.innerHTML = "";
      htmlSummaryEl.textContent = "";
      htmlLogEl.textContent = "";

      if (files.length === 0) {
        processHtmlBtn.disabled = true;
        htmlLog("No HTML files selected.");
        return;
      }

      processHtmlBtn.disabled = false;
      htmlLog(`Selected ${files.length} HTML file(s):`);
      files.forEach(f => htmlLog(" • " + f.name));
    });

    clearHtmlBtn.addEventListener("click", () => {
      selectedHtmlFiles = [];
      htmlFileInput.value = "";
      htmlDownloadsEl.innerHTML = "";
      htmlSummaryEl.textContent = "";
      htmlLogEl.textContent = "";
      processHtmlBtn.disabled = true;
    });

    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = err => reject(err);
        reader.readAsText(file, "utf-8");
      });
    }

    // Remove all tags except those in preserveSet; keep text
    function cleanPreservingSelected(html, preserveSet) {
      const wrapper = document.createElement("div");
      wrapper.innerHTML = html;

      function unwrapOthers(node) {
        const children = Array.from(node.childNodes);
        for (const child of children) {
          if (child.nodeType === Node.ELEMENT_NODE) {
            const tag = child.tagName.toLowerCase();
            if (!preserveSet.has(tag)) {
              // unwrap this tag but keep its children
              unwrapOthers(child);
              while (child.firstChild) {
                node.insertBefore(child.firstChild, child);
              }
              node.removeChild(child);
            } else {
              // preserve this tag and recurse into it
              unwrapOthers(child);
            }
          }
        }
      }

      unwrapOthers(wrapper);
      return wrapper.innerHTML.trim();
    }

    processHtmlBtn.addEventListener("click", async () => {
      if (selectedHtmlFiles.length === 0) return;

      processHtmlBtn.disabled = true;
      clearHtmlBtn.disabled = true;
      htmlDownloadsEl.innerHTML = "";
      htmlSummaryEl.textContent = "";
      htmlLogEl.textContent = "";

      // Build set of tags to preserve from checkboxes
      const preserveSet = new Set(
        Array.from(tagCheckboxes)
          .filter(cb => cb.checked)
          .map(cb => cb.value.toLowerCase())
      );

      if (preserveSet.size === 0) {
        htmlLog("Warning: no tags selected to preserve – output will be plain text only.");
      } else {
        htmlLog("Preserving tags: " + Array.from(preserveSet).map(t => "<" + t + ">").join(", "));
      }

      let totalFiles = 0;
      let totalLines = 0;
      let totalImages = 0;

      try {
        for (const file of selectedHtmlFiles) {
          htmlLog(`\nProcessing file: ${file.name}`);
          const text = await readFileAsText(file);

          const parser = new DOMParser();
          const doc = parser.parseFromString(text, "text/html");

          const selector = "h1,h2,h3,h4,h5,h6,p,footer,sup,small,b,i,u,img";
          const elements = Array.from(doc.querySelectorAll(selector));

          let mainLines = [];
          let imageFilenames = [];

          elements.forEach(el => {
            const tag = el.tagName.toLowerCase();

            if (tag === "img") {
              const src = el.getAttribute("src");
              if (src) {
                const parts = src.split(/[\\/]/);
                const filename = parts[parts.length - 1];
                imageFilenames.push(filename);
                mainLines.push(`[${filename}]`);
              }
            } else if (["h1","h2","h3","h4","h5","h6"].includes(tag)) {
              mainLines.push(el.outerHTML);
            } else {
              const innerHtml = el.innerHTML;
              if (!innerHtml || !innerHtml.trim()) return;
              const cleanedInner = cleanPreservingSelected(innerHtml, preserveSet);
              if (!cleanedInner) return;

              // If the outer element itself is in the preserve set, keep it too
              let line;
              if (preserveSet.has(tag)) {
                line = `<${tag}>${cleanedInner}</${tag}>`;
              } else {
                line = cleanedInner;
              }
              mainLines.push(line);
            }
          });

          const mainText = mainLines.join("\n");
          const imagesText = imageFilenames.join("\n");

          totalFiles += 1;
          totalLines += mainLines.length;
          totalImages += imageFilenames.length;

          const baseName = file.name.replace(/\.[^.]+$/, "");
          const mainBlob = new Blob([mainText], { type: "text/plain;charset=utf-8" });
          const imgBlob  = new Blob([imagesText], { type: "text/plain;charset=utf-8" });

          const mainUrl = URL.createObjectURL(mainBlob);
          const imgUrl  = URL.createObjectURL(imgBlob);

          const mainRow = document.createElement("div");
          mainRow.className = "file-item";
          const mainLeft = document.createElement("div");
          mainLeft.textContent = `${baseName}.txt`;
          const mainRight = document.createElement("div");
          const mainA = document.createElement("a");
          mainA.href = mainUrl;
          mainA.download = `${baseName}.txt`;
          mainA.className = "download-link";
          mainA.textContent = "Download extracted text";
          mainRight.appendChild(mainA);
          mainRow.appendChild(mainLeft);
          mainRow.appendChild(mainRight);

          const imgRow = document.createElement("div");
          imgRow.className = "file-item";
          const imgLeft = document.createElement("div");
          imgLeft.textContent = `${baseName}_image_files.txt`;
          const imgRight = document.createElement("div");
          const imgA = document.createElement("a");
          imgA.href = imgUrl;
          imgA.download = `${baseName}_image_files.txt`;
          imgA.className = "download-link";
          imgA.textContent = "Download image filename list";
          imgRight.appendChild(imgA);
          imgRow.appendChild(imgLeft);
          imgRow.appendChild(imgRight);

          htmlDownloadsEl.appendChild(mainRow);
          htmlDownloadsEl.appendChild(imgRow);

          htmlLog(
            `Finished "${file.name}" – ` +
            `${mainLines.length} content line(s), ${imageFilenames.length} image filename(s).`
          );
        }

        htmlSummaryEl.textContent =
          `Processed ${totalFiles} file(s). ` +
          `Total ${totalLines} content line(s) and ${totalImages} image filename(s).`;

        htmlLog("\nAll HTML files processed.");
      } catch (err) {
        htmlLog("Error processing HTML: " + (err.message || err));
        alert("Error: " + (err.message || err));
      } finally {
        clearHtmlBtn.disabled = false;
        processHtmlBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
