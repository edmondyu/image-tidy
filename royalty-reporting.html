<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toolbox – Royalty Reporting</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 1100px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #f5f5f5;
      color: #111827;
    }
    header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }
    h1 {
      margin: 0;
      font-size: 1.25rem;
    }
    .subtitle {
      margin: 0.35rem 0 0;
      color: #6b7280;
      font-size: 0.95rem;
      line-height: 1.4;
    }
    a.link {
      color: #2563eb;
      text-decoration: none;
      font-weight: 600;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.25rem;
      margin-top: 1.25rem;
    }
    @media (min-width: 900px) {
      .grid {
        grid-template-columns: 1.15fr 0.85fr;
      }
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 1.25rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }
    label {
      display: block;
      margin: 0.75rem 0 0.35rem;
      color: #6b7280;
      font-size: 0.85rem;
    }
    input[type="text"], input[type="file"] {
      width: 100%;
      box-sizing: border-box;
      padding: 0.65rem 0.75rem;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #fff;
      color: #111827;
    }
    .row {
      display: flex;
      gap: 0.6rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.9rem;
    }
    button {
      appearance: none;
      border: 0;
      border-radius: 999px;
      padding: 0.6rem 1.05rem;
      font-size: 0.9rem;
      background: #2563eb;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button.secondary {
      background: #111827;
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.8rem;
      background: #f3f4f6;
      color: #374151;
      border: 1px solid #e5e7eb;
    }
    .pill.ok {
      background: #ecfeff;
      border-color: #a5f3fc;
      color: #0e7490;
    }
    .pill.bad {
      background: #fff1f2;
      border-color: #fecdd3;
      color: #9f1239;
    }
    .small {
      margin-top: 0.65rem;
      font-size: 0.85rem;
      color: #6b7280;
      line-height: 1.5;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 0.82rem;
      background: #f3f4f6;
      padding: 0.12rem 0.4rem;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      color: #111827;
      white-space: nowrap;
    }
    pre {
      margin: 0;
      padding: 0.85rem;
      background: #0b1220;
      border-radius: 12px;
      color: #dbeafe;
      height: 360px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .note {
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: #fffbeb;
      border: 1px solid #fde68a;
      color: #92400e;
      font-size: 0.9rem;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Royalty Reporting (Multi-platform)</h1>
      <p class="subtitle">
        Upload CSV/XLSX reports, generate per-publisher summary CSVs, and download everything as a ZIP.
        All processing happens locally in your browser.
      </p>
    </div>
    <div>
      <a class="link" href="index.html">← Back to Toolbox</a>
    </div>
  </header>

  <div class="grid">
    <div class="card">
      <label>Date range label (used in output filenames & report title)</label>
      <input id="dateString" type="text" value="2024-10-01_to_2025-06-30" />

      <label>Upload source reports (multiple files allowed)</label>
      <input id="fileInput" type="file" multiple accept=".csv,.xlsx" />

      <div class="row">
        <button id="processBtn" disabled>Process</button>
        <button id="downloadBtn" class="secondary" disabled>Download ZIP</button>
        <span id="statusPill" class="pill">Idle</span>
      </div>

      <p class="small">
        Platform detection is based on the filename containing one of:
        <span class="kbd">Google</span>, <span class="kbd">kobo</span>, <span class="kbd">koboplus</span>,
        <span class="kbd">readmoo</span>, <span class="kbd">KDP</span>, <span class="kbd">hyread</span>
      </p>

      <div class="note">
        <strong>Copies rules</strong><br />
        Google: <span class="kbd">Qty</span> · Readmoo: <span class="kbd">銷售數量</span> · Kobo: <span class="kbd">Paid Units</span> ·
        KDP: <span class="kbd">Net Units Sold</span> · HyRead: <span class="kbd">借閱人數</span> only when <span class="kbd">備註</span> = <span class="kbd">單館採購</span> ·
        KoboPlus: not applicable
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content: space-between; margin-top: 0;">
        <span class="pill ok">Processing Status</span>
        <span class="pill">Live log</span>
      </div>
      <div style="margin-top: 0.75rem;">
        <pre id="log"></pre>
      </div>
    </div>
  </div>

  <!-- Libraries via CDN (works on Netlify static hosting) -->
  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- SheetJS for XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- JSZip for ZIP output -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    // =============================
    // Royalty Reporting Tool (browser-only)
    // =============================
    // Algorithm summary:
    // 1) User uploads multiple CSV/XLSX files.
    // 2) For each file:
    //    - Detect platform by filename keyword.
    //    - Parse rows.
    //    - Normalize column names to lowercase.
    //    - Read title/publisher/royalty.
    //    - Compute copies using platform-specific mapping.
    // 3) Combine all rows from all files.
    // 4) Group by publisher, then title, and build one report CSV per publisher.
    // 5) Package all per-publisher CSVs into a ZIP for download.

    const PLATFORMS = ['Google', 'kobo', 'koboplus', 'readmoo', 'KDP', 'hyread'];

    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const logEl = document.getElementById('log');
    const statusPill = document.getElementById('statusPill');
    const dateStringEl = document.getElementById('dateString');

    let lastZipBlobUrl = null;

    function setStatus(text, type = 'idle') {
      statusPill.textContent = text;
      statusPill.className = 'pill' + (type === 'ok' ? ' ok' : type === 'bad' ? ' bad' : '');
    }

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function resetDownload() {
      downloadBtn.disabled = true;
      if (lastZipBlobUrl) URL.revokeObjectURL(lastZipBlobUrl);
      lastZipBlobUrl = null;
    }

    fileInput.addEventListener('change', () => {
      const files = [...(fileInput.files || [])];
      processBtn.disabled = files.length === 0;
      resetDownload();
      logEl.textContent = '';
      setStatus(files.length ? `${files.length} file(s) selected` : 'Idle');
    });

    function detectPlatform(filename) {
      const lower = filename.toLowerCase();
      const sorted = [...PLATFORMS].sort((a, b) => b.length - a.length);
      for (const p of sorted) {
        if (lower.includes(p.toLowerCase())) return p;
      }
      return null;
    }

    function normalizeKeys(rowObj) {
      const out = {};
      for (const [k, v] of Object.entries(rowObj || {})) {
        if (k == null) continue;
        out[String(k).trim().toLowerCase()] = v;
      }
      return out;
    }

    function safeString(x, fallback) {
      const s = (x == null) ? '' : String(x).trim();
      return s === '' ? fallback : s;
    }

    function toNumber(x) {
      if (x == null) return 0;
      const s = String(x).replace(/,/g, '').trim();
      if (s === '') return 0;
      const n = Number(s);
      return Number.isFinite(n) ? n : 0;
    }

    function csvStringify(rows) {
      // Minimal CSV serializer with quoting
      const esc = (cell) => {
        const s = (cell == null) ? '' : String(cell);
        return /[",\n\r]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
      };
      return rows.map(r => r.map(esc).join(',')).join('\r\n');
    }

    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsText(file);
      });
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsArrayBuffer(file);
      });
    }

    async function parseCSVFile(file) {
      const text = await readFileAsText(file);
      const parsed = Papa.parse(text, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false
      });
      if (parsed.errors && parsed.errors.length) {
        log(`⚠️ CSV parse warnings in ${file.name}: ${parsed.errors[0].message}`);
      }
      return parsed.data || [];
    }

    async function parseXLSXFile(file) {
      const ab = await readFileAsArrayBuffer(file);
      const wb = XLSX.read(ab, { type: 'array' });
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      return XLSX.utils.sheet_to_json(ws, { defval: '' }) || [];
    }

    function deriveCopies(platform, rowLower) {
      // rowLower keys are already lowercased; Chinese keys remain unchanged
      if (platform === 'Google') return toNumber(rowLower['qty']);
      if (platform === 'readmoo') return toNumber(rowLower['銷售數量']);
      if (platform === 'kobo') return toNumber(rowLower['paid units']);
      if (platform === 'KDP') return toNumber(rowLower['net units sold']);
      if (platform === 'hyread') {
        const note = safeString(rowLower['備註'], '');
        return note === '單館採購' ? toNumber(rowLower['借閱人數']) : 0;
      }
      // koboplus: not applicable
      return 0;
    }

    async function processFiles(files, dateString) {
      setStatus('Processing…', 'ok');
      log(`Starting processing for ${files.length} file(s).`);

      // Unified dataset for all platforms
      // Each record: {title, publisher, royalty, copies, platform}
      const allRows = [];

      for (const file of files) {
        const platform = detectPlatform(file.name);
        if (!platform) {
          log(`Skipping (unknown platform by filename): ${file.name}`);
          continue;
        }

        log(`Reading ${file.name} as platform: ${platform}`);

        let rawRows = [];
        if (file.name.toLowerCase().endsWith('.xlsx')) rawRows = await parseXLSXFile(file);
        else rawRows = await parseCSVFile(file);

        log(`  Parsed ${rawRows.length} row(s) from ${file.name}`);

        for (const raw of rawRows) {
          const row = normalizeKeys(raw);

          // The original Python script requires 'royalty'.
          // If missing or non-numeric, it becomes 0.
          const royalty = toNumber(row['royalty']);

          // Title/publisher normalization
          const title = safeString(row['title'], '(Missing title)');
          const publisher = safeString(row['publisher'], 'Unknown_Publisher');

          // Platform-specific copies mapping
          const copies = deriveCopies(platform, row);

          allRows.push({ title, publisher, royalty, copies, platform });
        }
      }

      if (allRows.length === 0) {
        throw new Error('No usable rows found. Check filenames and required columns (title/publisher/royalty).');
      }

      log(`Combined dataset: ${allRows.length} row(s).`);

      // Group records by publisher
      const byPublisher = new Map();
      for (const r of allRows) {
        const pub = safeString(r.publisher, 'Unknown_Publisher');
        if (!byPublisher.has(pub)) byPublisher.set(pub, []);
        byPublisher.get(pub).push(r);
      }

      const expectedColumns = ['Title', 'Sold_Copies', ...PLATFORMS, 'Total'];
      const outputs = []; // {filename, content}

      for (const [publisher, rows] of byPublisher.entries()) {
        log(`Building report for publisher: ${publisher}`);

        // Group publisher records by title
        const byTitle = new Map();
        for (const r of rows) {
          const t = safeString(r.title, '(Missing title)');
          if (!byTitle.has(t)) byTitle.set(t, []);
          byTitle.get(t).push(r);
        }

        // Build one output row per title
        const table = [];
        for (const [title, tRows] of byTitle.entries()) {
          const soldCopies = Math.round(tRows.reduce((acc, x) => acc + (x.copies || 0), 0));

          const rowOut = { Title: title, Sold_Copies: soldCopies };
          let totalRoyalty = 0;

          for (const p of PLATFORMS) {
            const sumP = tRows.filter(x => x.platform === p).reduce((acc, x) => acc + (x.royalty || 0), 0);
            rowOut[p] = Math.round(sumP * 100) / 100;
            totalRoyalty += sumP;
          }
          rowOut['Total'] = Math.round(totalRoyalty * 100) / 100;
          table.push(rowOut);
        }

        // Add total row (sum numeric columns)
        const totalRow = { Title: 'Total' };
        for (const col of expectedColumns.slice(1)) totalRow[col] = 0;

        for (const r of table) {
          totalRow['Sold_Copies'] += toNumber(r['Sold_Copies']);
          for (const p of PLATFORMS) totalRow[p] += toNumber(r[p]);
          totalRow['Total'] += toNumber(r['Total']);
        }

        totalRow['Sold_Copies'] = Math.round(totalRow['Sold_Copies']);
        for (const p of PLATFORMS) totalRow[p] = Math.round(totalRow[p] * 100) / 100;
        totalRow['Total'] = Math.round(totalRow['Total'] * 100) / 100;

        // Payable calculation (same logic as the Python script)
        const totalRoyaltyValue = toNumber(totalRow['Total']);
        const distributionFee = Math.round(totalRoyaltyValue * 0.10 * 100) / 100;
        const withdrawalFee = 5.00;
        const payable = Math.round((totalRoyaltyValue - distributionFee - withdrawalFee) * 100) / 100;

        const reportTitle = `${publisher}（發行服務報表 ${dateString}）`;

        const csvRows = [];
        csvRows.push([reportTitle]);
        csvRows.push(expectedColumns);

        for (const r of table) csvRows.push(expectedColumns.map(c => r[c] ?? ''));
        csvRows.push(expectedColumns.map(c => totalRow[c] ?? ''));
        csvRows.push([]);
        csvRows.push(['Payable = Total royalty - 10% distribution fee - 5 USD withdrawal administration fee']);
        csvRows.push([`Total Payable: ${payable.toFixed(2)} USD`]);

        // Add UTF-8 BOM for better Excel compatibility (esp. Chinese columns)
        const csvContent = '\ufeff' + csvStringify(csvRows);

        const safePublisher = publisher.replace(/\s+/g, '_');
        const outName = `${safePublisher}_${dateString}_report.csv`;
        outputs.push({ filename: outName, content: csvContent });

        log(`  ✓ Created ${outName} (${table.length} title(s))`);
      }

      log(`Creating ZIP with ${outputs.length} report(s)…`);
      const zip = new JSZip();
      for (const o of outputs) zip.file(o.filename, o.content);
      const blob = await zip.generateAsync({ type: 'blob' });
      log('ZIP ready.');

      return { blob, outputsCount: outputs.length };
    }

    processBtn.addEventListener('click', async () => {
      resetDownload();
      logEl.textContent = '';

      const files = [...(fileInput.files || [])];
      const dateString = (dateStringEl.value || '').trim() || 'date_range';
      if (!files.length) return;

      processBtn.disabled = true;
      downloadBtn.disabled = true;

      try {
        const { blob, outputsCount } = await processFiles(files, dateString);
        lastZipBlobUrl = URL.createObjectURL(blob);
        downloadBtn.disabled = false;
        setStatus(`Done: ${outputsCount} report(s)`, 'ok');
        log('✅ Done. Click "Download ZIP".');
      } catch (err) {
        console.error(err);
        setStatus('Error', 'bad');
        log(`❌ Error: ${err.message || err}`);
      } finally {
        processBtn.disabled = false;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!lastZipBlobUrl) return;
      const dateString = (dateStringEl.value || '').trim() || 'date_range';

      const a = document.createElement('a');
      a.href = lastZipBlobUrl;
      a.download = `publisher_reports_${dateString}.zip`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      log('⬇️ Download started.');
    });

    setStatus('Idle');
  </script>
</body>
</html>
