<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Image Compression ‚Äì Toolbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
      background: #131313;
      color: #f9f9f9;
    }
    h1, h2 {
      margin-top: 0;
      margin-bottom: 0.25rem;
      color: #50e3c2;
    }
    .subtitle {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .card {
      background: #1f1f1f;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      margin-bottom: 1.5rem;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.1rem;
      font-size: 0.95rem;
      margin-right: 0.5rem;
    }
    button.primary {
      background: #50e3c2;
      color: #131313;
    }
    button.primary:hover:not(:disabled) {
      background: #3dd4b3;
    }
    button.secondary {
      background: #3a3a3a;
      color: #f9f9f9;
    }
    button.secondary:hover:not(:disabled) {
      background: #4a4a4a;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    input[type="file"] {
      margin: 0.75rem 0;
    }
    input[type="number"] {
      padding: 0.25rem 0.4rem;
      border-radius: 6px;
      border: 1px solid #3a3a3a;
      background: #2a2a2a;
      color: #f9f9f9;
      font-size: 0.9rem;
      width: 90px;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-top: 0.5rem;
    }
    .controls-row label {
      font-size: 0.9rem;
      color: #50e3c2;
    }
    .hint {
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .file-list {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0;
      border-bottom: 1px solid #2a2a2a;
    }
    .file-item:last-child {
      border-bottom: none;
    }
    .badge {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #2a2a2a;
      color: #50e3c2;
      margin-left: 0.4rem;
    }
    a.download-link {
      font-size: 0.85rem;
      text-decoration: none;
      color: #50e3c2;
      margin-left: 0.7rem;
    }
    a.download-link:hover {
      color: #3dd4b3;
    }
    .summary {
      font-size: 0.9rem;
      margin-top: 0.5rem;
      color: #f9f9f9;
    }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      background: #2a2a2a;
      color: #f9f9f9;
      padding: 1rem;
      border-radius: 8px;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    a.back {
      display: inline-block;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      text-decoration: none;
      color: #50e3c2;
    }
    a.back:hover {
      color: #3dd4b3;
    }
    .drop-zone {
      position: relative;
      border: 2px dashed #3a3a3a;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      transition: all 0.3s;
      background: #2a2a2a;
      margin-bottom: 1rem;
    }
    .drop-zone.drag-over {
      border-color: #50e3c2;
      background: #1a3a35;
    }
    .drop-zone p {
      margin: 0.5rem 0;
      color: #9ca3af;
    }
    .drop-zone .drop-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: #50e3c2;
    }
    .drop-zone input[type="file"] {
      display: none;
    }
    .drop-zone .file-input-wrapper {
      margin-top: 1rem;
    }
    .drop-zone .browse-btn {
      background: #3a3a3a;
      color: #f9f9f9;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      display: inline-block;
      font-size: 0.9rem;
    }
    .drop-zone .browse-btn:hover {
      background: #4a4a4a;
    }
    .drop-zone.has-file {
      border-color: #10b981;
      background: #064e3b;
    }
    .drop-zone.has-file .drop-icon {
      color: #10b981;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <a class="back" href="index.html">‚Üê Back to Toolbox</a>
  <h1>Image Compression</h1>
  <p class="subtitle">
    Resize and compress multiple images in the browser. All processing is done locally.
  </p>

  <div class="card">
    <h2>1. Select Images & Parameters</h2>
    <p>Supported formats: <strong>.png, .jpg, .jpeg</strong></p>
    <div class="drop-zone" id="imgDropZone">
      <div class="drop-icon">üñºÔ∏è</div>
      <p><strong>Drag and drop images here</strong></p>
      <p>or</p>
      <div class="file-input-wrapper">
        <label for="img-file-input" class="browse-btn">Browse Files</label>
        <input id="img-file-input" type="file" multiple accept=".png,.jpg,.jpeg,image/png,image/jpeg" />
      </div>
    </div>

    <div class="controls-row">
      <label for="max-width-input">Max width (px):</label>
      <input id="max-width-input" type="number" min="100" max="10000" step="1" value="1800" />

      <label for="max-height-input">Max height (px):</label>
      <input id="max-height-input" type="number" min="100" max="10000" step="1" value="1800" />
    </div>

    <div class="controls-row">
      <label for="target-percent-input">Target size (% of resized):</label>
      <input id="target-percent-input" type="number" min="1" max="100" step="1" value="50" />
      <span class="hint">
        Example: 50 ‚Üí compressed file ‚âà 50% of resized file size.
      </span>
    </div>
    <div class="controls-row">
      <label>
        <input id="enable-resize-checkbox" type="checkbox" checked />
        Enable resize (fit within max width/height)
      </label>
      <label>
        <input id="convert-to-jpg-checkbox" type="checkbox" checked />
        Convert output to JPG
      </label>
      <span class="hint">
        If JPG conversion is off, PNG outputs won‚Äôt honor target size % (PNG quality is not adjustable).
      </span>
    </div>


    <div class="file-list" id="img-file-list"></div>
  </div>

  <div class="card">
    <h2>2. Process & Download</h2>
    <button id="process-images-btn" class="primary" disabled>Process Images</button>
    <button id="zip-images-btn" class="secondary" disabled>Download All as ZIP</button>
    <button id="clear-images-btn" class="secondary">Clear</button>
    <p class="summary" id="img-summary"></p>
    <div id="img-downloads"></div>
  </div>

  <div class="card">
    <h2>Logs</h2>
    <div class="log" id="img-log"></div>
  </div>

  <script>
    const imgFileInput      = document.getElementById("img-file-input");
    const imgDropZone       = document.getElementById("imgDropZone");
    const maxWidthInput     = document.getElementById("max-width-input");
    const maxHeightInput    = document.getElementById("max-height-input");
    const targetPercentInput= document.getElementById("target-percent-input");
    const enableResizeCheckbox = document.getElementById("enable-resize-checkbox");
    const convertToJpgCheckbox = document.getElementById("convert-to-jpg-checkbox");
    const processImagesBtn  = document.getElementById("process-images-btn");
    const clearImagesBtn    = document.getElementById("clear-images-btn");
    const zipImagesBtn      = document.getElementById("zip-images-btn");
    const imgLogEl          = document.getElementById("img-log");
    const imgFileListEl     = document.getElementById("img-file-list");
    const imgDownloadsEl    = document.getElementById("img-downloads");
    const imgSummaryEl      = document.getElementById("img-summary");

    let selectedImgFiles = [];
    let processedImgResults = [];

    // Drag and drop helper functions
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(dropZone) {
      dropZone.classList.add('drag-over');
    }

    function unhighlight(dropZone) {
      dropZone.classList.remove('drag-over');
    }

    function setupDropZone(dropZone, onDrop) {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
      });

      dropZone.addEventListener('dragenter', () => highlight(dropZone), false);
      dropZone.addEventListener('dragover', () => highlight(dropZone), false);
      dropZone.addEventListener('dragleave', (e) => {
        if (e.target === dropZone) {
          unhighlight(dropZone);
        }
      }, false);
      dropZone.addEventListener('drop', (e) => {
        unhighlight(dropZone);
        onDrop(e);
      }, false);
    }

    function imgLog(message) {
      imgLogEl.textContent += message + "\n";
      imgLogEl.scrollTop = imgLogEl.scrollHeight;
    }

    function bytesToKB(bytes) {
      return (bytes / 1024).toFixed(2) + " KB";
    }

    function replaceExtensionToJpg(name) {
      return name.replace(/\.[^.]+$/, "") + ".jpg";
    }

    function naturalSortKey(str) {
      return str.split(/(\d+)/).map(part => {
        const n = parseInt(part, 10);
        return isNaN(n) ? part.toLowerCase() : n;
      });
    }

    function naturalCompare(a, b) {
      const ak = naturalSortKey(a);
      const bk = naturalSortKey(b);
      const len = Math.max(ak.length, bk.length);
      for (let i = 0; i < len; i++) {
        if (ak[i] === undefined) return -1;
        if (bk[i] === undefined) return 1;
        if (ak[i] < bk[i]) return -1;
        if (ak[i] > bk[i]) return 1;
      }
      return 0;
    }

    function updateImgFileList() {
      imgFileListEl.innerHTML = "";
      if (selectedImgFiles.length === 0) {
        imgFileListEl.textContent = "No files selected.";
        processImagesBtn.disabled = true;
        return;
      }
      const frag = document.createDocumentFragment();
      selectedImgFiles.forEach(file => {
        const div = document.createElement("div");
        div.className = "file-item";
        const nameSpan = document.createElement("span");
        nameSpan.textContent = file.name;
        const sizeSpan = document.createElement("span");
        sizeSpan.textContent = bytesToKB(file.size);
        div.appendChild(nameSpan);
        div.appendChild(sizeSpan);
        frag.appendChild(div);
      });
      imgFileListEl.appendChild(frag);
      processImagesBtn.disabled = false;
    }

    function clearImageTool() {
      selectedImgFiles = [];
      processedImgResults = [];
      imgFileInput.value = "";
      imgFileListEl.textContent = "No files selected.";
      imgDownloadsEl.innerHTML = "";
      imgSummaryEl.textContent = "";
      processImagesBtn.disabled = true;
      zipImagesBtn.disabled = true;
      imgLogEl.textContent = "";
      imgDropZone.classList.remove('has-file');
    }

    function syncResizeControls() {
      const enabled = enableResizeCheckbox.checked;
      maxWidthInput.disabled = !enabled;
      maxHeightInput.disabled = !enabled;
    }


    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = err => reject(err);
          img.src = e.target.result;
        };
        reader.onerror = err => reject(err);
        reader.readAsDataURL(file);
      });
    }

    function canvasToBlob(canvas, type = "image/jpeg", quality = 0.85) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (!blob) reject(new Error("Canvas is empty"));
          else resolve(blob);
        }, type, quality);
      });
    }

    function getValidatedMaxWidth() {
      const val = parseInt(maxWidthInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val) || val <= 0) {
        throw new Error("Max width must be a positive integer.");
      }
      if (val < 100 || val > 10000) {
        throw new Error("Max width must be between 100 and 10000 pixels.");
      }
      return val;
    }

    function getValidatedMaxHeight() {
      const val = parseInt(maxHeightInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val) || val <= 0) {
        throw new Error("Max height must be a positive integer.");
      }
      if (val < 100 || val > 10000) {
        throw new Error("Max height must be between 100 and 10000 pixels.");
      }
      return val;
    }

    function getValidatedTargetPercent() {
      const val = parseInt(targetPercentInput.value, 10);
      if (isNaN(val) || !Number.isInteger(val)) {
        throw new Error("Target size must be an integer percentage.");
      }
      if (val < 1 || val > 100) {
        throw new Error("Target size percentage must be between 1 and 100.");
      }
      return val;
    }

    async function resizeImageBrowser(img, maxWidth, maxHeight, enableResize, outputType = "image/jpeg") {
      let { width, height } = img;
      let newWidth = width;
      let newHeight = height;
      let resized = false;

      if (enableResize && (width > maxWidth || height > maxHeight)) {
        const scaleW = maxWidth / width;
        const scaleH = maxHeight / height;
        const scale = Math.min(scaleW, scaleH);
        newWidth = Math.round(width * scale);
        newHeight = Math.round(height * scale);
        resized = true;
      }

      const canvas = document.createElement("canvas");
      canvas.width = newWidth;
      canvas.height = newHeight;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, newWidth, newHeight);
      ctx.drawImage(img, 0, 0, newWidth, newHeight);

      const resizedBlob = await canvasToBlob(canvas, outputType, 0.85);
      return { canvas, resizedBlob, resized, width, height, newWidth, newHeight };
    }

    async function compressImageFromCanvas(canvas, resizedBlob, targetPercent, outputType = "image/jpeg") {
      const originalSize = resizedBlob.size;
      if (outputType !== "image/jpeg") {
        return await canvasToBlob(canvas, outputType, 0.85);
      }
      const targetRatio = targetPercent / 100;
      const targetSize = originalSize * targetRatio;
      let quality = 0.8;
      let compressedBlob = resizedBlob;
      while (true) {
        const blob = await canvasToBlob(canvas, "image/jpeg", quality);
        const size = blob.size;
        if (size <= targetSize || quality <= 0.1) {
          compressedBlob = blob;
          break;
        }
        quality -= 0.05;
      }
      return compressedBlob;
    }

    function handleFileSelection(files) {
      const filtered = files.filter(f => /\.(png|jpe?g)$/i.test(f.name));
      filtered.sort((a, b) => naturalCompare(a.name, b.name));
      selectedImgFiles = filtered;
      processedImgResults = [];
      imgDownloadsEl.innerHTML = "";
      imgSummaryEl.textContent = "";
      zipImagesBtn.disabled = true;
      imgLogEl.textContent = "";
      if (files.length !== filtered.length) {
        imgLog("Some files were ignored (unsupported extension).");
      }
      if (filtered.length === 0) {
        imgFileListEl.textContent = "No valid image files selected.";
        processImagesBtn.disabled = true;
        imgDropZone.classList.remove('has-file');
      } else {
        updateImgFileList();
        imgLog(`Selected ${filtered.length} image(s).`);
        imgDropZone.classList.add('has-file');
      }
    }

    imgFileInput.addEventListener("change", () => {
      const files = Array.from(imgFileInput.files || []);
      handleFileSelection(files);
    });

    setupDropZone(imgDropZone, (e) => {
      const files = Array.from(e.dataTransfer.files);
      const imageFiles = files.filter(f => /\.(png|jpe?g)$/i.test(f.name));
      if (imageFiles.length > 0) {
        const dataTransfer = new DataTransfer();
        imageFiles.forEach(file => dataTransfer.items.add(file));
        imgFileInput.files = dataTransfer.files;
        handleFileSelection(imageFiles);
      }
    });

    clearImagesBtn.addEventListener("click", clearImageTool);

    enableResizeCheckbox.addEventListener("change", syncResizeControls);
    syncResizeControls();

    processImagesBtn.addEventListener("click", async () => {
      if (selectedImgFiles.length === 0) return;

      let maxWidth, maxHeight, targetPercent;
      try {
        maxWidth = getValidatedMaxWidth();
        maxHeight = getValidatedMaxHeight();
        targetPercent = getValidatedTargetPercent();
      } catch (err) {
        imgLog("Parameter error: " + err.message);
        alert(err.message);
        return;
      }

      const enableResize = enableResizeCheckbox.checked;
      const convertToJpg = convertToJpgCheckbox.checked;

      imgLog(
        `Using max width: ${maxWidth}px, max height: ${maxHeight}px, ` +
        `target size: ${targetPercent}% of resized file size.`
      );

      processImagesBtn.disabled = true;
      clearImagesBtn.disabled = true;
      zipImagesBtn.disabled = true;
      imgDownloadsEl.innerHTML = "";
      processedImgResults = [];
      imgSummaryEl.textContent = "";
      imgLog(`Starting processing of ${selectedImgFiles.length} image(s)...`);

      let totalOriginal = 0;
      let totalCompressed = 0;

      for (let i = 0; i < selectedImgFiles.length; i++) {
        const file = selectedImgFiles[i];
        const index = i + 1;
        imgLog(`\n[${index}/${selectedImgFiles.length}] Processing "${file.name}"`);

        totalOriginal += file.size;

        try {
          const outputType = convertToJpg
            ? "image/jpeg"
            : (/\.png$/i.test(file.name) ? "image/png" : "image/jpeg");
          const outputName = convertToJpg ? replaceExtensionToJpg(file.name) : file.name;

          const img = await loadImageFromFile(file);
          const {
            canvas,
            resizedBlob,
            resized,
            width,
            height,
            newWidth,
            newHeight
          } = await resizeImageBrowser(img, maxWidth, maxHeight, enableResize, outputType);

          const resizedKB = bytesToKB(resizedBlob.size);
          if (resized) {
            imgLog(`Resized from ${width}x${height} to ${newWidth}x${newHeight}, size ~ ${resizedKB}`);
          } else {
            imgLog(`No resize needed (${width}x${height}), saved as ${outputType === "image/png" ? "PNG" : "JPEG"} ~ ${resizedKB}`);
          }

          const compressedBlob = await compressImageFromCanvas(canvas, resizedBlob, targetPercent, outputType);
          const compressedKB = bytesToKB(compressedBlob.size);
          totalCompressed += compressedBlob.size;

          if (outputType === "image/png") {
            imgLog(`PNG output created (~ ${compressedKB}); target % is not enforced for PNG.`);
          } else {
            imgLog(`Compressed to ~ ${compressedKB} (target <= ${targetPercent}% of resized size)`);
          }

          const url = URL.createObjectURL(compressedBlob);

          processedImgResults.push({
            name: outputName,
            originalSize: file.size,
            resizedSize: resizedBlob.size,
            compressedSize: compressedBlob.size,
            blob: compressedBlob,
            url
          });

          const row = document.createElement("div");
          row.className = "file-item";

          const left = document.createElement("div");
          left.textContent = outputName;
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = `${bytesToKB(file.size)} ‚Üí ${compressedKB}`;
          left.appendChild(badge);

          const right = document.createElement("div");
          const a = document.createElement("a");
          a.href = url;
          a.download = outputName;
          a.className = "download-link";
          a.textContent = "Download";
          right.appendChild(a);

          row.appendChild(left);
          row.appendChild(right);
          imgDownloadsEl.appendChild(row);

        } catch (err) {
          imgLog(`Error processing "${file.name}": ${err.message || err}`);
        }
      }

      const savingPercent =
        totalOriginal > 0
          ? ((1 - totalCompressed / totalOriginal) * 100).toFixed(1)
          : 0;

      imgSummaryEl.textContent =
        `Done. Total original: ${bytesToKB(totalOriginal)} ‚Üí ` +
        `${bytesToKB(totalCompressed)} (saved ~${savingPercent}%).`;

      imgLog("\nAll images processed.");
      processImagesBtn.disabled = false;
      clearImagesBtn.disabled = false;

      if (processedImgResults.length > 0) {
        zipImagesBtn.disabled = false;
      }
    });

    zipImagesBtn.addEventListener("click", async () => {
      if (processedImgResults.length === 0) return;

      zipImagesBtn.disabled = true;
      const originalLabel = zipImagesBtn.textContent;
      zipImagesBtn.textContent = "Preparing ZIP...";

      try {
        const zip = new JSZip();
        processedImgResults.forEach(result => {
          zip.file(result.name, result.blob);
        });

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "compressed_images.zip";
        document.body.appendChild(a);
        a.click();
        a.remove();

        setTimeout(() => URL.revokeObjectURL(url), 10000);
      } catch (err) {
        imgLog(`Error creating ZIP: ${err.message || err}`);
      } finally {
        zipImagesBtn.textContent = originalLabel;
        zipImagesBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
